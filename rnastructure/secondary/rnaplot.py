"""
This package provides a parser for the postscript files generated by RNAplot.
"""

import re

import rnastructure.secondary.basic as basic

START_PAIRS = re.compile('^/pairs\s*\[$')
END_PAIRS = re.compile('^\]\s*def$')
PAIR = re.compile('^\[(\d+)\s*(\d+)\]$')

START_COORD = re.compile('^/coor\s*\[$')
END_COORD = re.compile('^]\s*def$')
COORD = re.compile('^\[(-?\d+\.\d+)\s*(-?\d+\.\d+)\]$')

START_SEQUENCE = re.compile(r"/sequence")
END_SEQUENCE = re.compile('^\)\s*def$')
SEQUENCE = re.compile('^(\w+)[^\w]?$')

BOX = re.compile('%%BoundingBox:\s*(\d+)\s*(\d+)\s*(\d+)\s*(\d+)')


class NoLocationAnnotations(Exception):
    """This error is raise when we cannot find the part of the postscript which
    specifies where to put the nucleotides.
    """
    pass


class NoPairsAnnotations(Exception):
    """This error is raised when we cannot find the pairing information in the
    psotscript.
    """
    pass


class NoSequenceAnnotation(Exception):
    """This exception is raised if we cannot find the part of the postscript
    that specifies the sequence.
    """
    pass


class Parser(basic.Parser):
    """This is a class to read a postscript file generated by the output of
    RNAplot to get the 2D information as well as coordinates to draw an
    airport diagram.
    """

    def __init__(self, stream):
        self.pairs = []
        self.sequence = ''
        self.locations = []
        self.box = ()
        while True:
            try:
                line = stream.next()
                command = line.split(" ")[0]
                if START_SEQUENCE.match(command):
                    self.ali_sequence = self.__sequence__(stream)
                elif START_COORD.match(line):
                    self.locations = self.__locations__(stream)
                elif START_PAIRS.match(line):
                    self.pairs = self.__pairs__(stream)
                elif BOX.match(line):
                    match = BOX.match(line)
                    self.box = (int(match.group(1)), int(match.group(2)),
                                int(match.group(3)), int(match.group(4)))
            except StopIteration:
                break

        if not self.pairs:
            raise NoPairsAnnotations("Did not find any pairs")

        if not self.ali_sequence:
            raise NoSequenceAnnotation("Did not find the sequence")

        if not self.locations:
            raise NoLocationAnnotations("Did not find drawing coordinates")

        super(Parser, self).__init__(self.pairs)

    def __locations__(self, stream):
        locations = []
        for line in stream:
            if END_COORD.match(line):
                break
            match = COORD.match(line)
            if match:
                loc = (float(match.group(1)), float(match.group(2)))
                locations.append(loc)

        if not locations:
            raise NoLocationAnnotations("No location annotations")

        return locations

    def __pairs__(self, stream):
        if not self.locations:
            raise NoLocationAnnotations("Locations must come before pairs")

        pairs = [None] * len(self.locations)
        for line in stream:
            if END_PAIRS.match(line):
                break
            match = PAIR.match(line)
            if match:
                first = int(match.group(1)) - 1
                second = int(match.group(2)) - 1
                pairs[first] = second
                pairs[second] = first

        if not pairs:
            raise NoPairsAnnotations("Could not find any pairs annotations")

        return pairs

    def __sequence__(self, stream):
        sequence = []
        for line in stream:
            line = line.rstrip()
            if END_SEQUENCE.match(line):
                break

            match = SEQUENCE.match(line)
            if match:
                sequence.append(match.group(1))

        return ''.join(sequence)
