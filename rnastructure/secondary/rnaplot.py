"""
This package provides a parser for the postscript files generated by RNAplot.
"""

import os
import re
import abc
import xml.etree.ElementTree as ET

import rnastructure.secondary.basic as basic
import rnastructure.secondary.dot_bracket as db
import rnastructure.util.wrapper as wrapper


class NoLocationAnnotations(Exception):
    """This error is raise when we cannot find the part of the postscript which
    specifies where to put the nucleotides.
    """
    pass


class NoPairsAnnotations(Exception):
    """This error is raised when we cannot find the pairing information in the
    psotscript.
    """
    pass


class NoSequenceAnnotation(Exception):
    """This exception is raised if we cannot find the part of the postscript
    that specifies the sequence.
    """
    pass


class UnimplementedParser(Exception):
    """This is raised when we need a parser that we have not yet implemented to
    parse the results of RNAplot.
    """
    pass


class UnparsableSVG(Exception):
    """This is raised if we can't parse the SVG file for any reason.
    """
    pass


class Parser(basic.Parser):
    """This is the basic parser for all parsers produced by RNAplot.
    """
    __metaclass__ = abc.ABCMeta

    def __init__(self, stream):
        sequence = None
        self.locations = []
        """The locations of coordinates to draw."""
        self.box = ()
        """The bounding box of the drawing."""

        sequence, pairs = self.load_data(stream)

        if not pairs:
            raise NoPairsAnnotations("Did not find any pairs")

        if sequence is None:
            raise NoSequenceAnnotation("Did not find the sequence")

        if not self.locations:
            raise NoLocationAnnotations("Did not find drawing coordinates")

        super(Parser, self).__init__(pairs, sequence=sequence)

    @abc.abstractmethod
    def load_data(self, stream):
        """This method should load all data from the stream. It should return
        the pairs and set self.sequence, self.locations, and self.box for this
        object.

        :stream: The data stream to read.
        :returns: The pairs.
        """
        pass


class PostScriptParser(Parser):
    """This is a class to read a postscript file generated by the output of
    RNAplot to get the 2D information as well as coordinates to draw an
    airport diagram.
    """

    start_pairs_pattern = re.compile('^/pairs\s*\[$')
    end_pairs_pattern = re.compile('^\]\s*def$')
    pair_pattern = re.compile('^\[(\d+)\s*(\d+)\]$')

    start_coord_pattern = re.compile('^/coor\s*\[$')
    end_coord_pattern = re.compile('^]\s*def$')
    coord_pattern = re.compile('^\[(-?\d+\.\d+)\s*(-?\d+\.\d+)\]$')

    start_sequence_pattern = re.compile(r"/sequence")
    end_sequence_pattern = re.compile('^\)\s*def$')
    sequence_pattern = re.compile('^(\w+)[^\w]?$')

    box_pattern = re.compile('%%BoundingBox:\s*(\d+)\s*(\d+)\s*(\d+)\s*(\d+)')

    def load_data(self, stream):
        pairs = []
        while True:
            try:
                line = stream.next()
                command = line.split(" ")[0]
                if self.start_sequence_pattern.match(command):
                    sequence = self.__sequence__(stream)
                elif self.start_coord_pattern.match(line):
                    self.locations = self.__locations__(stream)
                elif self.start_pairs_pattern.match(line):
                    pairs = self.__pairs__(stream)
                elif self.box_pattern.match(line):
                    match = self.box_pattern.match(line)
                    self.box = (int(match.group(1)), int(match.group(2)),
                                int(match.group(3)), int(match.group(4)))
            except StopIteration:
                break
        return sequence, pairs

    def __locations__(self, stream):
        locations = []
        for line in stream:
            if self.end_coord_pattern.match(line):
                break
            match = self.coord_pattern.match(line)
            if match:
                loc = (float(match.group(1)), float(match.group(2)))
                locations.append(loc)

        if not locations:
            raise NoLocationAnnotations("No location annotations")

        return locations

    def __pairs__(self, stream):
        if not self.locations:
            raise NoLocationAnnotations("Locations must come before pairs")

        pairs = [None] * len(self.locations)
        for line in stream:
            if self.end_pairs_pattern.match(line):
                break
            match = self.pair_pattern.match(line)
            if match:
                first = int(match.group(1)) - 1
                second = int(match.group(2)) - 1
                pairs[first] = second
                pairs[second] = first

        if not pairs:
            raise NoPairsAnnotations("Could not find any pairs annotations")

        return pairs

    def __sequence__(self, stream):
        sequence = []
        for line in stream:
            line = line.rstrip()
            if self.end_sequence_pattern.match(line):
                break

            match = self.sequence_pattern.match(line)
            if match:
                sequence.append(match.group(1))

        return ''.join(sequence)


class SVGParser(Parser):
    """This is a class to parse the svg files produced by RNAplot.
    """

    def load_data(self, stream):
        tree = ET.parse(stream)
        root = tree.getroot()
        container = None
        for child in root:
            if child.tag == '{http://www.w3.org/2000/svg}g':
                container = child
                break

        if container is None:
            raise UnparsableSVG("Cannot find container")

        self.box = self.__box__(root)
        sequence, self.locations = self.__locations__(container)
        return sequence, self.__pairs__(container)

    def __pairs__(self, root):
        pair_node = None
        size = None
        for child in root:
            if child.attrib.get('id', None) == 'pairs':
                pair_node = child
            if child.attrib.get('id', None) == 'seq':
                size = len(child)

        if pair_node is None:
            raise NoPairsAnnotations("Couldn't find the pairs")

        if size is None:
            raise NoSequenceAnnotation("Couldn't find the sequence")

        pairs = [None] * size
        for pair in pair_node:
            pair = map(lambda i: int(i) - 1, pair.attrib['id'].split(','))
            pairs[pair[0]] = pair[1]
            pairs[pair[1]] = pair[0]

        return pairs

    def __box__(self, root):
        return (0, 0, int(root.attrib['width']), int(root.attrib['height']))

    def __locations__(self, root):
        # TODO: Deal with the required transforms
        seq_node = None
        for child in root:
            if child.attrib.get('id', None) == 'seq':
                seq_node = child
                break

        if seq_node is None:
            raise NoSequenceAnnotation("Could not find sequence")

        sequence = []
        locations = []
        for node in seq_node:
            sequence.append(node.text)
            locations.append((float(node.attrib['x']),
                              float(node.attrib['y'])))
        return ''.join(sequence), locations


class RNAplot(wrapper.Wrapper):
    """This is a wrapper around RNAplot so we an generate 2D diagrams from a
    known 2D. This will not fold things, instead it will simply draw them. It
    accepts a parsed 2D structure and then returns a parsed 2D structure with
    details on the coordinates. For details of the returned parser, see Parser
    in this package.
    """

    program = 'RNAplot'
    options = {
        'output_format': wrapper.is_in('ps', 'gml', 'xrna', 'svg'),
        'layout_type': wrapper.is_in(0, 1)
    }
    accepted_files = [('rna.ps', PostScriptParser),
                      ('rna.svg', SVGParser)]

    def __init__(self):
        super(RNAplot, self).__init__(None)

    def results(self, process, temp_dir, filename):
        import glob
        print(glob.glob(temp_dir + '/*'))

        for name, klass in self.accepted_files:
            filename = os.path.join(temp_dir, name)
            print(filename, os.path.isfile(filename))

            if os.path.isfile(filename):
                with open(filename, 'rb') as raw:
                    return klass(raw)

        # os.rmdir(temp_dir)

        raise UnimplementedParser("Don't yet have required parser.")

    def input_file(self, input_file, raw):
        pass

    def generate_arguments(self, filename, options):
        return []

    def validate_input(self, raw):
        return isinstance(raw, basic.Parser) and raw.sequence and \
            len(filter(None, raw.sequence)) == len(raw.sequence)

    def stdin(self, temp_dir, raw, options):
        data = (raw.sequence, db.Writer().format(raw))
        return "%s\n%s\n@\n" % data

    def __call__(self, secondary, **kwargs):
        """Create a drawing of the given secondary structure.

        :secondary: A parsed secondary structure.
        :layout_type: One of 0, 1 to indicate the type of layout, radial or
        naview.
        :output_format: One of ps, gml, xrna, svg to indicate the type of
        output format.
        :returns: A RNAplot.Parser object representing the diagram.
        """
        super(RNAplot, self).__call__(secondary, options=kwargs)
